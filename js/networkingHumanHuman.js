/**
 * Networking Module for Human-Human Experiments
 *
 * Contains all networking and socket.io functions for multiplayer experiments.
 * Extracted from human-human-version.js for better organization.
 */

// Global networking state variables
let socket = null;
let gameState = null;
let myPlayerId = null;
let partnerPlayerId = null;
let roomId = null;
let isConnected = false;
let isGameActive = false;
let movementMode = 'simultaneous';

// Track all players in the room
let roomPlayers = [];

// Player order tracking for consistent colors
var playerOrder = {
    firstPlayerId: null,  // First player to join (should be red)
    secondPlayerId: null, // Second player to join (should be orange)
    isFirstPlayer: false  // Whether current player is the first player
};

// Callback registration system to prevent duplicate socket handlers
let registeredCallbacks = {
    gameStarted: null,
    moveUpdate: null,
    trialComplete: null,
    newGoal: null,
    newGoalFailed: null,
    fallbackGoal: null
};

// Make playerOrder globally accessible for viz.js
window.playerOrder = playerOrder;

/**
 * Initialize Socket.IO connection
 */
function initializeSocket() {
    if (socket && socket.connected) {
        console.log('Socket already connected');
        return;
    }

    console.log('Initializing socket connection...');
    console.log('ðŸŽ® Attempting to connect to server...');

    try {
        socket = io();
        console.log('ðŸŽ® Socket.io instance created');
    } catch (error) {
        console.error('âŒ Failed to create socket.io instance:', error);
        return;
    }

    socket.on('connect', () => {
        console.log('âœ… Connected to server with ID:', socket.id);
        isConnected = true;
        myPlayerId = socket.id;

        // Make myPlayerId globally accessible
        window.myPlayerId = myPlayerId;
        console.log('ðŸŽ® Set myPlayerId to:', myPlayerId);

        // Ensure gameData.multiplayer exists before setting properties
        if (typeof gameData !== 'undefined') {
            if (!gameData.multiplayer) {
                gameData.multiplayer = {};
            }
            gameData.multiplayer.myPlayerId = myPlayerId;
        }
    });

    socket.on('connect_error', (error) => {
        console.error('âŒ Connection failed:', error);
        isConnected = false;

        // Update UI if we're in the matching stage
        const matchingStatus = document.getElementById('matchingStatus');
        if (matchingStatus) {
            matchingStatus.innerHTML = 'Failed to connect to server. Please check if the server is running and refresh the page.';
        }
    });

    socket.on('disconnect', () => {
        console.log('Disconnected from server');
        isConnected = false;
        handleDisconnection();
    });

    socket.on('joined_room', handleRoomJoined);
    socket.on('player_joined', handlePartnerJoined);
    socket.on('player_left', handlePartnerLeft);
    socket.on('room_full', handleRoomFull);
    socket.on('game_started', (data) => {
        console.log('ðŸŽ® RECEIVED game_started event:', data);
        handleGameStarted(data);
    });
    socket.on('move_made', recordMoveMultiPlayer);
    socket.on('trial_complete', handleTrialComplete);
    socket.on('collaboration_feedback', showCollaborationFeedback);
    socket.on('trial_started', handleTrialStarted);

    // Handle 2P3G-specific events for server-side goal generation
    socket.on('server_new_goal', (data) => {
        console.log('ðŸŽ¯ Server-side new goal generation event received:', data);
        console.log('ðŸŽ¯ New goal position:', data.newGoal || data.newGoalPosition);
        console.log('ðŸŽ¯ Distance condition:', data.distanceCondition);
        console.log('ðŸŽ¯ Generated by:', data.generatedBy);

        // CRITICAL: Validate server response data
        if (!data.newGoal && !data.newGoalPosition) {
            console.error('âŒ Server new goal event missing goal position');
            return;
        }

        if (registeredCallbacks.newGoal) {
            registeredCallbacks.newGoal(data);
        } else {
            console.log('â„¹ï¸ No new goal callback registered - storing for later use');
            // Store the event for when callback is registered
            window.pendingServerNewGoal = data;
        }
    });

    socket.on('server_new_goal_failed', (data) => {
        console.log('ðŸš« Server-side new goal generation failed:', data);
        console.log('ðŸš« Failure reason:', data.reason);
        console.log('ðŸš« Distance condition:', data.distanceCondition);

        if (registeredCallbacks.newGoalFailed) {
            registeredCallbacks.newGoalFailed(data);
        } else {
            console.log('â„¹ï¸ No new goal failed callback registered');
            // Fallback: Show error message to user
            if (typeof showErrorMessage === 'function') {
                showErrorMessage('Failed to generate new goal: ' + (data.reason || 'Unknown error'));
            }
        }
    });

    socket.on('share_fallback_goal', (data) => {
        console.log('ðŸŽ¯ Server-side fallback goal shared:', data);
        if (registeredCallbacks.fallbackGoal) {
            registeredCallbacks.fallbackGoal(data);
        } else {
            console.log('â„¹ï¸ No fallback goal callback registered');
        }
    });

    socket.on('error', (error) => {
        console.error('Socket error:', error);
        showErrorMessage('Connection error: ' + error);
    });

    // Reconnection handling
    socket.on('reconnect', () => {
        console.log('Reconnected to server');
        isConnected = true;
        // Attempt to rejoin room if we were in one
        if (roomId) {
            joinMultiplayerRoom();
        }
    });

    socket.on('reconnect_error', (error) => {
        console.error('Reconnection failed:', error);
        // Show reconnection message
        showReconnectionMessage();
    });

    socket.on('connect_error', (error) => {
        console.error('Connection failed:', error);
        isConnected = false;
    });
}

/**
 * Handle room joined event
 */
function handleRoomJoined(data) {
    console.log('Joined room:', data);
    roomId = data.roomId;
    myPlayerId = data.playerId;

    // Update global myPlayerId
    window.myPlayerId = myPlayerId;
    console.log('ðŸŽ® Updated myPlayerId to:', myPlayerId);

    // Add ourselves to the room players list
    if (!roomPlayers.includes(myPlayerId)) {
        roomPlayers.push(myPlayerId);
        console.log('ðŸŽ® Added myself to room players:', roomPlayers);
    }

    // Store in gameData
    if (typeof gameData !== 'undefined' && gameData.multiplayer) {
        gameData.multiplayer.roomId = roomId;
        gameData.multiplayer.myPlayerId = myPlayerId;
    }

    // Update status
    updateConnectionStatus(`Joined room ${roomId}. Waiting for partner...`);

    // Don't auto-advance here - wait for room_full event
    console.log('Room joined successfully, waiting for partner to join...');
}

/**
 * Handle room full event (both players joined)
 */
function handleRoomFull(data) {
    console.log('Room is now full - both players joined:', data);
    console.log('ðŸŽ® Room players tracked:', roomPlayers);
    console.log('ðŸŽ® My player ID:', myPlayerId);

    // Prevent multiple calls
    if (window.roomFullHandled) {
        console.log('Room full already handled, ignoring duplicate call');
        return;
    }
    window.roomFullHandled = true;

    // Set partner ID based on tracked players
    if (roomPlayers.length === 2) {
        // Find the other player (our partner)
        const otherPlayer = roomPlayers.find(playerId => playerId !== myPlayerId);
        if (otherPlayer) {
            partnerPlayerId = otherPlayer;
            if (typeof gameData !== 'undefined' && gameData.multiplayer) {
                gameData.multiplayer.partnerPlayerId = partnerPlayerId;
            }
            console.log('âœ… Partner ID set from room players:', partnerPlayerId);
        } else {
            console.error('âŒ Could not identify partner from room players');
        }
    } else {
        console.error('âŒ Expected 2 players in room, but found:', roomPlayers.length);
    }

    // For human-human timeline, advance to the next stage instead of showing ready message immediately
    // The timeline will handle the proper sequence: matching -> game_ready -> trial
    console.log('Room full - advancing to next timeline stage (player matching)');

    // Auto-advance to next stage (should be player_matching stage)
    setTimeout(() => {
        nextStage();
    }, 1000);

    // Set a timeout to prevent infinite waiting
    window.gameStartTimeout = setTimeout(() => {
        console.log('â° Game start timeout reached');
        showErrorMessage('Partner not responding. Please refresh the page.');
        window.roomFullHandled = false; // Reset for retry
    }, 15000); // 15 second timeout

    // Only let the first player (determined by socket ID comparison) send the map design
    setTimeout(() => {
        // Determine if I should send the map design (smaller socket ID sends the map)
        // This ensures consistent behavior regardless of event order
        const allPlayerIds = roomPlayers.slice().sort(); // Sort for consistent ordering
        const shouldSendMapDesign = roomPlayers.length === 2 && allPlayerIds[0] === myPlayerId;

        console.log('ðŸŽ® Map design decision:', {
            myPlayerId: myPlayerId,
            roomPlayers: roomPlayers,
            sortedPlayers: allPlayerIds,
            shouldSendMapDesign: shouldSendMapDesign
        });

        if (shouldSendMapDesign) {
            console.log('ðŸŽ® I am the designated map sender - checking for pending trial design');

            // Use the trial design stored by the trial handler for server-side map generation
            if (typeof gameData !== 'undefined' && gameData.pendingTrialDesign) {
                console.log('ðŸ—ºï¸ Sending trial design to server for server-side map generation:', gameData.pendingTrialDesign);

                socket.emit('start_trial', {
                    trialIndex: gameData.pendingTrialIndex || 0,
                    experimentType: gameData.currentExperiment,
                    design: gameData.pendingTrialDesign,
                    playerId: myPlayerId
                });

                console.log('âœ… Trial design sent to server for server-side map generation');

                // Clear the pending design after sending
                gameData.pendingTrialDesign = null;
                gameData.pendingTrialIndex = null;
            } else {
                console.warn('âš ï¸ No pending trial design available - server will use random selection');
            }
        } else {
            console.log('ðŸŽ® I am NOT the designated map sender - waiting for server to generate map');

            // Clear pending design since we're not sending it
            if (typeof gameData !== 'undefined') {
                gameData.pendingTrialDesign = null;
                gameData.pendingTrialIndex = null;
            }
        }

        // Wait a bit for map design to be processed, then send player ready
        setTimeout(() => {
            // Send player ready signal to server
            if (socket && socket.connected) {
                console.log('ðŸŽ® Sending player_ready signal to server');
                socket.emit('player_ready', {
                    roomId: roomId,
                    playerId: myPlayerId
                });
            } else {
                console.error('âŒ Socket not connected, cannot send player_ready signal');
                showErrorMessage('Connection error. Please refresh the page.');
                if (window.gameStartTimeout) {
                    clearTimeout(window.gameStartTimeout);
                    window.gameStartTimeout = null;
                }
            }
        }, 1000); // Wait 1 second for map processing

    }, 500); // Wait 500ms before deciding map sender
}

/**
 * Handle partner joined event
 */
function handlePartnerJoined(data) {
    console.log('ðŸŽ® Partner joined event received:', data);
    console.log('ðŸŽ® My player ID:', myPlayerId);
    console.log('ðŸŽ® Joining player ID:', data.playerId);
    console.log('ðŸŽ® Are they the same?', data.playerId === myPlayerId);

    // Add the joining player to our room players list
    if (!roomPlayers.includes(data.playerId)) {
        roomPlayers.push(data.playerId);
        console.log('ðŸŽ® Added joining player to room players:', roomPlayers);
    }

    // The player_joined event sends the joining player's ID
    // We need to set this as our partner's ID (since we're already in the room)
    // But only if it's not our own ID
    if (data.playerId !== myPlayerId) {
        partnerPlayerId = data.playerId;
        if (typeof gameData !== 'undefined' && gameData.multiplayer) {
            gameData.multiplayer.partnerPlayerId = partnerPlayerId;
        }

        console.log('âœ… Partner ID set to:', partnerPlayerId);
        updateConnectionStatus('Partner found! Starting game...');
    } else {
        console.log('â„¹ï¸ Received own player_joined event, ignoring');
    }
}

/**
 * Handle partner left event
 */
function handlePartnerLeft(data) {
    console.log('Partner left:', data);

    // Remove the leaving player from our room players list
    const playerIndex = roomPlayers.indexOf(data.playerId);
    if (playerIndex !== -1) {
        roomPlayers.splice(playerIndex, 1);
        console.log('ðŸŽ® Removed leaving player from room players:', roomPlayers);
    }

    // The player_left event sends the leaving player's ID
    // If this is our partner, clear the partner ID
    if (data.playerId === partnerPlayerId) {
        partnerPlayerId = null;
        if (typeof gameData !== 'undefined' && gameData.multiplayer) {
            gameData.multiplayer.partnerPlayerId = null;
        }
        showPartnerDisconnectedMessage();
    }
}

/**
 * Handle disconnection
 */
function handleDisconnection() {
    isConnected = false;
    isGameActive = false;

    // Clean up game state
    if (gameState) {
        gameState = null;
    }

    // Reset room players tracking
    roomPlayers = [];
    console.log('ðŸŽ® Reset room players tracking on disconnection');

    // Show disconnection message
    showDisconnectionMessage();

    // Attempt reconnection
    setTimeout(attemptReconnection, 2000);
}

/**
 * Join multiplayer room
 */
function joinMultiplayerRoom() {
    // Initialize socket if not already done
    if (!socket || !socket.connected) {
        console.log('Socket not connected, attempting to initialize...');
        if (typeof initializeSocket === 'function') {
            initializeSocket();
        } else {
            console.error('initializeSocket function not available');
            showErrorMessage('Socket initialization failed. Please refresh the page.');
            return false;
        }
    }

    // Wait a moment for socket to connect
    setTimeout(() => {
        if (!socket || !socket.connected) {
            console.error('Socket still not connected after initialization');
            showErrorMessage('Connection failed. Please refresh the page.');
            return false;
        }

        // Reset room players tracking for new room
        roomPlayers = [];
        console.log('ðŸŽ® Reset room players tracking for new room');

        console.log('Requesting to join multiplayer room...');
        console.log('ðŸŽ® Current experiment type:', gameData.currentExperiment);
        console.log('ðŸŽ® My player ID:', myPlayerId);

        // Use a default experiment type if currentExperiment is not set
        const experimentType = gameData.currentExperiment || '2P2G';
        console.log('ðŸŽ® Using experiment type for room join:', experimentType);

        socket.emit('join_game', {
            gameType: experimentType,
            playerId: myPlayerId
        });

        return true;
    }, 1000); // Wait 1 second for socket to connect
}

/**
 * Start multiplayer trial
 */
function startMultiplayerTrial(trialIndex, design) {
    if (!socket || !socket.connected) {
        console.error('Socket not connected. Cannot start trial.');
        showErrorMessage('Not connected to server. Please refresh the page.');
        return;
    }

    console.log('Starting multiplayer trial:', trialIndex, design);

    socket.emit('start_trial', {
        trialIndex: trialIndex,
        experimentType: gameData.currentExperiment,
        design: design,
        roomId: roomId
    });
}

/**
 * Convert array movement to string direction
 */
function convertMovementToDirection(movement) {
    if (Array.isArray(movement)) {
        if (movement[0] === -1 && movement[1] === 0) return 'up';
        if (movement[0] === 1 && movement[1] === 0) return 'down';
        if (movement[0] === 0 && movement[1] === -1) return 'left';
        if (movement[0] === 0 && movement[1] === 1) return 'right';
    }
    return movement; // Return as-is if not an array
}

/**
 * Make a move in multiplayer game
 */
function makeMultiplayerMove(action) {
    console.log('ðŸŽ® makeMultiplayerMove called with action:', action);
    console.log('ðŸŽ® Socket connected:', socket && socket.connected);
    console.log('ðŸŽ® Game active:', isGameActive);

    if (!socket || !socket.connected) {
        console.error('Socket not connected. Cannot make move.');
        return;
    }

    if (!isGameActive) {
        console.log('Game not active. Ignoring move.');
        return;
    }

    // Convert array movement to string direction
    const direction = convertMovementToDirection(action);
    console.log('Making multiplayer move:', action, '->', direction);

    socket.emit('make_move', {
        action: direction,
        playerId: myPlayerId,
        roomId: roomId,
        timestamp: Date.now()
    });
}

/**
 * Record move from multiplayer partner (centralized)
 */
function recordMoveMultiPlayer(data) {
    console.log('ðŸŽ® Received move from server (centralized handler):', data);
    console.log('ðŸŽ® My player ID:', myPlayerId);
    console.log('ðŸŽ® Partner player ID:', partnerPlayerId);

    // First call any registered game-specific callback
    if (registeredCallbacks.moveUpdate) {
        console.log('ðŸ”„ Calling registered move update callback');
        registeredCallbacks.moveUpdate(data);
        return; // Let the game-specific handler manage everything
    } else {
        console.log('â„¹ï¸ No move update callback registered, using default handler');
    }
    console.log('ðŸŽ® Room players tracked:', roomPlayers);

    if (!data.gameState) {
        console.error('No game state received from server');
        return;
    }

    // Update local game state
    gameState = data.gameState;

    // Update player positions AND game matrix
    // Assign player positions correctly based on player order (not perspective)
    // player1 should always be the first player (red), player2 should always be the second player (orange)
    if (data.gameState.players && data.gameState.players[myPlayerId] && data.gameState.players[partnerPlayerId]) {
        console.log('ðŸ”„ GAME STATE UPDATE DEBUG:');
        console.log('  - Server game state players:', data.gameState.players);
        console.log('  - My ID:', myPlayerId, 'Partner ID:', partnerPlayerId);
        console.log('  - I am first player:', playerOrder.isFirstPlayer);

        if (playerOrder.isFirstPlayer) {
            // I am the first player (red) - I should be player1
            gameData.player1 = data.gameState.players[myPlayerId].position;
            gameData.player2 = data.gameState.players[partnerPlayerId].position;
            console.log('âœ… I am first player (red) - player1 (me):', gameData.player1, 'player2 (partner):', gameData.player2);
        } else {
            // I am the second player (orange) - partner should be player1
            gameData.player1 = data.gameState.players[partnerPlayerId].position;
            gameData.player2 = data.gameState.players[myPlayerId].position;
            console.log('âœ… I am second player (orange) - player1 (partner):', gameData.player1, 'player2 (me):', gameData.player2);
        }
    }

    // CRITICAL: Update the grid matrix from server to ensure synchronization
    if (data.gameState.gridMatrix) {
        gameData.gridMatrix = data.gameState.gridMatrix;
        console.log('ðŸ”„ Updated grid matrix from server:', gameData.gridMatrix.length + 'x' + gameData.gridMatrix[0]?.length);
    } else {
        console.warn('âš ï¸ No grid matrix in server game state');
    }

    // Update goals from server
    if (data.gameState.goals) {
        gameData.currentGoals = data.gameState.goals;
        console.log('ðŸ”„ Updated goals from server:', gameData.currentGoals);
    } else {
        console.warn('âš ï¸ No goals in server game state');
    }

    // Handle case where player data is missing
    if (!data.gameState.players || !data.gameState.players[myPlayerId] || !data.gameState.players[partnerPlayerId]) {
        console.log('â„¹ï¸ No partner position update - partnerPlayerId:', partnerPlayerId);
        console.log('Available players:', Object.keys(data.gameState.players || {}));
        console.log('Game state players:', data.gameState.players);

        // Try to find partner by checking all players in game state
        const availablePlayers = Object.keys(data.gameState.players || {});
        const otherPlayer = availablePlayers.find(playerId => playerId !== myPlayerId);
        if (otherPlayer) {
            console.log('ðŸŽ® Found other player in game state:', otherPlayer);
            gameData.player2 = data.gameState.players[otherPlayer].position;
            console.log('âœ… Updated player2 position using fallback method:', gameData.player2);
        } else {
            console.error('âŒ No other player found in game state');
        }
    }

    // Update step count
    if (data.gameState.stepCount !== undefined) {
        gameData.stepCount = data.gameState.stepCount;
    }

    // Update visualization
    if (typeof updateGameVisualization === 'function') {
        updateGameVisualization();
        console.log('âœ… Game visualization updated');
    } else {
        console.error('âŒ updateGameVisualization function not available');
    }

    // CRITICAL: Update the player color indicator to match current game state
    if (typeof window.updatePlayerColorIndicator === 'function') {
        window.updatePlayerColorIndicator();
        console.log('âœ… Player color indicator updated after game state change');
    } else {
        // Fallback: directly update the color indicator
        const colorIndicator = document.getElementById('playerColorIndicator');
        if (colorIndicator && playerOrder && typeof playerOrder.isFirstPlayer !== 'undefined') {
            const playerColor = playerOrder.isFirstPlayer ? 'red' : 'orange';
            colorIndicator.style.backgroundColor = playerColor;
            console.log('ðŸŽ¨ Fallback: Updated player color indicator to:', playerColor);
        }
    }

    // Record move data for later analysis
    if (data.move && data.move.playerId === partnerPlayerId) {
        recordPartnerMove(data.move.action, data.move.reactionTime);
    }
}

/**
 * Handle game started event (centralized)
 */
function handleGameStarted(data) {
    console.log('ðŸŽ® Game started event received (centralized handler):', data);
    console.log('ðŸŽ® My player ID:', myPlayerId);
    console.log('ðŸŽ® Game state:', data.gameState);

    // First call any registered game-specific callback
    if (registeredCallbacks.gameStarted) {
        console.log('ðŸ”„ Calling registered game-specific callback');
        registeredCallbacks.gameStarted(data);
    } else {
        console.log('â„¹ï¸ No game-specific callback registered, using default handler');
    }

    // Clear any game start timeout since the game is actually starting
    if (window.gameStartTimeout) {
        clearTimeout(window.gameStartTimeout);
        window.gameStartTimeout = null;
    }

    // Reset room full handled flag for next trial
    window.roomFullHandled = false;

    isGameActive = true;
    gameState = data.gameState;

    // Set player order based on server assignment
    if (data.playerOrder) {
        playerOrder.firstPlayerId = data.playerOrder.firstPlayerId;
        playerOrder.secondPlayerId = data.playerOrder.secondPlayerId;
        playerOrder.isFirstPlayer = (myPlayerId === data.playerOrder.firstPlayerId);

        console.log('ðŸŽ® Player order assignment:');
        console.log('  - First player (red):', data.playerOrder.firstPlayerId);
        console.log('  - Second player (orange):', data.playerOrder.secondPlayerId);
        console.log('  - My player ID:', myPlayerId);
        console.log('  - I am first player:', playerOrder.isFirstPlayer);
        console.log('  - My color should be:', playerOrder.isFirstPlayer ? 'RED' : 'ORANGE');
        console.log('  - playerOrder object after assignment:', playerOrder);
    }

    // Update game data with server-generated map and synchronized state
    if (data.gameState) {
        console.log('ðŸ”„ SERVER-GENERATED GAME STATE SYNC:');
        console.log('  - Server players:', data.gameState.players);
        console.log('  - I am first player:', playerOrder.isFirstPlayer);

        if (playerOrder.isFirstPlayer) {
            // I am the first player (red) - I should be player1
            gameData.player1 = data.gameState.players[myPlayerId]?.position || [0, 0];
            gameData.player2 = data.gameState.players[partnerPlayerId]?.position || [0, 0];
            console.log('âœ… Initial sync - I am first (red): player1 (me):', gameData.player1, 'player2 (partner):', gameData.player2);
        } else {
            // I am the second player (orange) - partner should be player1
            gameData.player1 = data.gameState.players[partnerPlayerId]?.position || [0, 0];
            gameData.player2 = data.gameState.players[myPlayerId]?.position || [0, 0];
            console.log('âœ… Initial sync - I am second (orange): player1 (partner):', gameData.player1, 'player2 (me):', gameData.player2);
        }

        // Sync all game state components from server-generated map
        gameData.currentGoals = data.gameState.goals || [];
        gameData.gridMatrix = data.gameState.gridMatrix || [];
        gameData.currentPlayer = data.currentPlayer;
        gameData.stepCount = data.gameState.stepCount || 0;

        console.log('ðŸ”„ Server-generated game state synchronized:', {
            goals: gameData.currentGoals,
            gridSize: gameData.gridMatrix.length + 'x' + gameData.gridMatrix[0]?.length,
            stepCount: gameData.stepCount
        });
    }

    // CRITICAL: Auto-advance timeline when game starts from waiting stage
    if (typeof timeline !== 'undefined' && timeline.stages && timeline.currentStage >= 0) {
        const currentStage = timeline.stages[timeline.currentStage];
        if (currentStage && currentStage.type === 'waiting_for_partner') {
            console.log('ðŸŽ® Game started! Auto-advancing from waiting stage to first trial.');
            // Clear any existing timeouts first
            if (window.gameStartTimeout) {
                clearTimeout(window.gameStartTimeout);
                window.gameStartTimeout = null;
            }
            // Advance to next stage (should be fixation -> trial)
            setTimeout(() => {
                nextStage();
            }, 100);
        } else {
            console.log('ðŸŽ® Game started event received in stage:', currentStage?.type);
        }
    }

    // Update display with server-generated game state
    if (typeof updateGameVisualization === 'function') {
        updateGameVisualization();
        console.log('âœ… Game visualization updated with server-generated state');
    } else {
        console.error('âŒ updateGameVisualization function not available');
    }

    // Update player color indicator
    if (typeof updatePlayerColorIndicator === 'function') {
        updatePlayerColorIndicator();
        console.log('âœ… Player color indicator updated');
    } else {
        console.log('â„¹ï¸ updatePlayerColorIndicator function not available, trying fallback');
        // Fallback: directly update the color indicator
        const colorIndicator = document.getElementById('playerColorIndicator');
        if (colorIndicator && playerOrder && playerOrder.isFirstPlayer !== undefined) {
            const playerColor = playerOrder.isFirstPlayer ? 'red' : 'orange';
            colorIndicator.style.backgroundColor = playerColor;
            console.log('ðŸŽ¨ Fallback: Updated player color indicator to:', playerColor);
        }
    }

    console.log('Multiplayer game started successfully with server-generated map');
    console.log('Game state:', {
        player1: gameData.player1,
        player2: gameData.player2,
        goals: gameData.currentGoals,
        gridMatrix: gameData.gridMatrix ? 'Grid matrix loaded' : 'No grid matrix',
        currentPlayer: gameData.currentPlayer,
        stepCount: gameData.stepCount
    });
}

/**
 * Handle trial started event
 */
function handleTrialStarted(data) {
    console.log('Trial started by server:', data);

    // Update trial index and game state
    gameData.currentTrial = data.trialIndex;

    if (data.gameState) {
        gameState = data.gameState;

        // Update local game data
        if (gameState.players && gameState.players[myPlayerId]) {
            gameData.player1 = gameState.players[myPlayerId].position;
        }

        if (gameState.players && gameState.players[partnerPlayerId]) {
            gameData.player2 = gameState.players[partnerPlayerId].position;
        } else if (partnerPlayerId) {
            console.log('â„¹ï¸ Partner not yet available in trial state');
        }

        if (gameState.goals) {
            gameData.currentGoals = gameState.goals;
        }

        if (gameState.gridMatrix) {
            gameData.gridMatrix = gameState.gridMatrix;
        }
    }

    // Initialize trial data
    initializeTrialData(data.trialIndex, gameData.currentExperiment);

    // Update visualization
    updateGameVisualization();

    isGameActive = true;
}

/**
 * Handle trial complete event (centralized)
 */
function handleTrialComplete(data) {
    console.log('Trial completed (centralized handler):', data);

    // First call any registered game-specific callback
    if (registeredCallbacks.trialComplete) {
        console.log('ðŸ”„ Calling registered trial complete callback');
        registeredCallbacks.trialComplete(data);
        return; // Let the game-specific handler manage everything
    } else {
        console.log('â„¹ï¸ No trial complete callback registered, using default handler');
    }

    isGameActive = false;

    // Update final game state
    if (data.gameState) {
        gameState = data.gameState;
    }

    // Record collaboration result
    if (data.collaborationSucceeded !== undefined) {
        gameData.currentTrialData.collaborationSucceeded = data.collaborationSucceeded;
    }

    // Record final positions and goals
    if (data.finalGoals) {
        gameData.currentTrialData.player1FinalReachedGoal = data.finalGoals.player1Goal;
        gameData.currentTrialData.player2FinalReachedGoal = data.finalGoals.player2Goal;
    }

    // Finalize trial
    finalizeTrial(data.completed || false);

    // Proceed to next stage after delay (use the same delay as post-trial stage)
    setTimeout(() => {
        nextStage();
    }, NODEGAME_CONFIG.timing.feedbackDisplayDuration);
}

/**
 * Show collaboration feedback
 */
function showCollaborationFeedback(data) {
    console.log('Showing collaboration feedback:', data);

    var container = document.getElementById('container');
    var feedbackMessage = '';

    if (data.collaborationSucceeded) {
        feedbackMessage = `
            <div style="text-align: center; color: green; font-size: 24px; margin: 20px;">
                <h2>ðŸŽ‰ Success!</h2>
                <p>You and your partner reached the same goal!</p>
            </div>
        `;
    } else {
        feedbackMessage = `
            <div style="text-align: center; color: #ff6b6b; font-size: 24px; margin: 20px;">
                <h2>No collaboration</h2>
                <p>You and your partner reached different goals.</p>
            </div>
        `;
    }

    container.innerHTML = feedbackMessage;

    // Auto-advance after showing feedback
    setTimeout(() => {
        nextStage();
    }, NODEGAME_CONFIG.timing.feedbackDisplayDuration);
}

/**
 * Update connection status display
 */
function updateConnectionStatus(message) {
    var statusElement = document.getElementById('statusMessage');
    if (statusElement) {
        statusElement.textContent = message;
    }
    console.log('Status:', message);
}

/**
 * Attempt reconnection
 */
function attemptReconnection() {
    if (socket && !socket.connected) {
        console.log('Attempting to reconnect...');
        updateConnectionStatus('Attempting to reconnect...');
        socket.connect();
    }
}

/**
 * Show server not running message
 */
function showServerNotRunningMessage() {
    var container = document.getElementById('container');
    container.innerHTML = `
        <div style="display: flex; align-items: center; justify-content: center; min-height: 100vh; background: #f8f9fa;">
            <div style="text-align: center; max-width: 600px; padding: 20px;">
                <h2 style="color: #dc3545; margin-bottom: 20px;">Server Not Available</h2>
                <p style="font-size: 18px; margin-bottom: 15px;">
                    The multiplayer server is not currently running. This is required for human-human experiments.
                </p>
                <p style="font-size: 16px; color: #6c757d; margin-bottom: 20px;">
                    Please contact the experiment administrator or try again later.
                </p>
                <button onclick="location.reload()"
                        style="background: #007bff; color: white; border: none; padding: 10px 20px; font-size: 16px; border-radius: 5px; cursor: pointer;">
                    Retry Connection
                </button>
            </div>
        </div>
    `;
}

/**
 * Show error message
 */
function showErrorMessage(message) {
    var container = document.getElementById('container');
    container.innerHTML = `
        <div style="display: flex; align-items: center; justify-content: center; min-height: 100vh; background: #f8f9fa;">
            <div style="text-align: center; max-width: 600px; padding: 20px;">
                <h2 style="color: #dc3545; margin-bottom: 20px;">Connection Error</h2>
                <p style="font-size: 18px; margin-bottom: 15px;">${message}</p>
                <button onclick="location.reload()"
                        style="background: #007bff; color: white; border: none; padding: 10px 20px; font-size: 16px; border-radius: 5px; cursor: pointer;">
                    Reload Page
                </button>
            </div>
        </div>
    `;
}

/**
 * Show partner disconnected message
 */
function showPartnerDisconnectedMessage() {
    var container = document.getElementById('container');
    container.innerHTML = `
        <div style="display: flex; align-items: center; justify-content: center; min-height: 100vh; background: #f8f9fa;">
            <div style="text-align: center; max-width: 600px; padding: 20px;">
                <h2 style="color: #ffc107; margin-bottom: 20px;">Partner Disconnected</h2>
                <p style="font-size: 18px; margin-bottom: 15px;">
                    Your partner has left the game. Waiting for a new partner...
                </p>
                <div style="margin: 20px 0;">
                    <div style="border: 3px solid #f3f3f3; border-top: 3px solid #ffc107; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto;"></div>
                </div>
                <button onclick="location.reload()"
                        style="background: #6c757d; color: white; border: none; padding: 10px 20px; font-size: 16px; border-radius: 5px; cursor: pointer;">
                    Start Over
                </button>
            </div>
        </div>
        <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        </style>
    `;
}

/**
 * Show disconnection message
 */
function showDisconnectionMessage() {
    var container = document.getElementById('container');
    container.innerHTML = `
        <div style="display: flex; align-items: center; justify-content: center; min-height: 100vh; background: #f8f9fa;">
            <div style="text-align: center; max-width: 600px; padding: 20px;">
                <h2 style="color: #dc3545; margin-bottom: 20px;">Connection Lost</h2>
                <p style="font-size: 18px; margin-bottom: 15px;">
                    Lost connection to the server. Attempting to reconnect...
                </p>
                <div style="margin: 20px 0;">
                    <div style="border: 3px solid #f3f3f3; border-top: 3px solid #dc3545; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto;"></div>
                </div>
                <button onclick="location.reload()"
                        style="background: #007bff; color: white; border: none; padding: 10px 20px; font-size: 16px; border-radius: 5px; cursor: pointer;">
                    Reload Page
                </button>
            </div>
        </div>
        <style>
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        </style>
    `;
}

/**
 * Show reconnection message
 */
function showReconnectionMessage() {
    updateConnectionStatus('Reconnection failed. Please reload the page.');
}

/**
 * Show game ready message
 */
function showGameReadyMessage() {
    var container = document.getElementById('container');
    container.innerHTML = `
        <div style="display: flex; align-items: center; justify-content: center; min-height: 100vh; background: #f8f9fa;">
            <div style="max-width: 600px; margin: 20px; background: white; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); padding: 40px; text-align: center;">
                <h1 style="color: #28a745; margin-bottom: 30px;">âœ… Game is Ready!</h1>

                <div style="margin: 40px 0;">
                    <div style="width: 80px; height: 80px; background-color: #28a745; border-radius: 50%; display: flex; align-items: center; justify-content: center; margin: 0 auto;">
                        <svg width="40" height="40" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z" fill="white"/>
                        </svg>
                    </div>
                </div>

                <div style="font-size: 20px; color: #333; margin-bottom: 20px;">
                    <p><strong>Partner found and connection established!</strong></p>
                    <p>The game is ready to begin.</p>
                </div>

                <div style="background: #d4edda; border: 1px solid #c3e6cb; padding: 15px; border-radius: 5px; margin-bottom: 20px;">
                    <p style="margin: 0; font-size: 16px; color: #155724;">
                        <strong>Press the space bar to start the game.</strong>
                    </p>
                </div>
            </div>
        </div>
    `;

    // Add event listener for space bar to continue
    function handleSpacebar(event) {
        if (event.code === 'Space' || event.key === ' ') {
            event.preventDefault();
            document.removeEventListener('keydown', handleSpacebar);

            // Send player_ready event to server
            if (socket) {
                console.log('Sending player_ready event from showGameReadyMessage');
                socket.emit('player_ready', {});
            }

            // Clear any existing timeouts
            if (window.gameStartTimeout) {
                clearTimeout(window.gameStartTimeout);
                window.gameStartTimeout = null;
            }

            // Advance to next stage
            console.log('Game ready, advancing to next stage');
            nextStage();
        }
    }

    document.addEventListener('keydown', handleSpacebar);
    document.body.focus();
}

/**
 * Advance to next stage (wrapper for timeline navigation)
 */
function nextStage() {
    // CRITICAL: Call the actual timeline navigation, not this function recursively
    if (typeof timeline !== 'undefined' && timeline.stages) {
        timeline.currentStage++;
        if (timeline.currentStage < timeline.stages.length) {
            var stage = timeline.stages[timeline.currentStage];
            console.log(`NetworkingHumanHuman: Moving to stage ${timeline.currentStage}: ${stage.type}`);
            stage.handler(stage);
        } else {
            console.log('NetworkingHumanHuman: Timeline complete');
        }
    } else if (typeof window.NodeGameHumanHuman !== 'undefined' && window.NodeGameHumanHuman.nextStage) {
        window.NodeGameHumanHuman.nextStage();
    } else {
        console.warn('nextStage function not available - no timeline or NodeGameHumanHuman found');
    }
}

/**
 * Callback registration functions
 */
function registerGameStartedCallback(callback) {
    console.log('ðŸ”§ Registering game started callback');
    registeredCallbacks.gameStarted = callback;
}

function registerMoveCallback(callback) {
    console.log('ðŸ”§ Registering move update callback');
    registeredCallbacks.moveUpdate = callback;
}

function registerTrialCompleteCallback(callback) {
    console.log('ðŸ”§ Registering trial complete callback');
    registeredCallbacks.trialComplete = callback;
}

function registerNewGoalCallback(callback) {
    console.log('ðŸ”§ Registering new goal callback');
    registeredCallbacks.newGoal = callback;

    // CRITICAL: Check for pending server new goal events
    if (window.pendingServerNewGoal) {
        console.log('ðŸŽ¯ Processing pending server new goal event:', window.pendingServerNewGoal);
        callback(window.pendingServerNewGoal);
        window.pendingServerNewGoal = null;
    }
}

function registerNewGoalFailedCallback(callback) {
    console.log('ðŸ”§ Registering new goal failed callback');
    registeredCallbacks.newGoalFailed = callback;

    // Check for pending failed goal events
    if (window.pendingServerNewGoalFailed) {
        console.log('ðŸš« Processing pending server new goal failed event:', window.pendingServerNewGoalFailed);
        callback(window.pendingServerNewGoalFailed);
        window.pendingServerNewGoalFailed = null;
    }
}

function registerFallbackGoalCallback(callback) {
    console.log('ðŸ”§ Registering fallback goal callback');
    registeredCallbacks.fallbackGoal = callback;
}

function clearAllCallbacks() {
    console.log('ðŸ§¹ Clearing all registered callbacks');
    Object.keys(registeredCallbacks).forEach(key => {
        registeredCallbacks[key] = null;
    });
}

// Export functions for module usage
window.NetworkingHumanHuman = {
    // Connection management
    initializeSocket: initializeSocket,
    joinMultiplayerRoom: joinMultiplayerRoom,
    attemptReconnection: attemptReconnection,

    // Game actions
    startMultiplayerTrial: startMultiplayerTrial,
    makeMultiplayerMove: makeMultiplayerMove,

    // Event handlers
    handleRoomJoined: handleRoomJoined,
    handlePartnerJoined: handlePartnerJoined,
    handlePartnerLeft: handlePartnerLeft,
    handleGameStarted: handleGameStarted,
    handleTrialStarted: handleTrialStarted,
    handleTrialComplete: handleTrialComplete,
    recordMoveMultiPlayer: recordMoveMultiPlayer,
    showCollaborationFeedback: showCollaborationFeedback,

    // Status and messaging
    updateConnectionStatus: updateConnectionStatus,
    showServerNotRunningMessage: showServerNotRunningMessage,
    showErrorMessage: showErrorMessage,
    showPartnerDisconnectedMessage: showPartnerDisconnectedMessage,
    showDisconnectionMessage: showDisconnectionMessage,
    showGameReadyMessage: showGameReadyMessage,

    // Callback registration
    registerGameStartedCallback: registerGameStartedCallback,
    registerMoveCallback: registerMoveCallback,
    registerTrialCompleteCallback: registerTrialCompleteCallback,
    registerNewGoalCallback: registerNewGoalCallback,
    registerNewGoalFailedCallback: registerNewGoalFailedCallback,
    registerFallbackGoalCallback: registerFallbackGoalCallback,
    clearAllCallbacks: clearAllCallbacks,

    // State getters
    getSocket: () => socket,
    getGameState: () => gameState,
    getMyPlayerId: () => myPlayerId,
    getPartnerPlayerId: () => partnerPlayerId,
    getRoomId: () => roomId,
    isConnected: () => isConnected,
    isGameActive: () => isGameActive,
    getPlayerOrder: () => playerOrder,

    // Timeline navigation
    nextStage: nextStage
};